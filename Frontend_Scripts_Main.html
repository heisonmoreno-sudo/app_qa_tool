<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     FRONTEND_SCRIPTS_MAIN.HTML
     JavaScript principal del sistema QA Management
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->

<script>
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // FUNCIONES DE SPINNER Y LOADING
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function mostrarSpinner() {
        const overlay = document.getElementById("loadingOverlay");
        if (overlay) {
            overlay.classList.add("active");

            // Mensajes aleatorios de carga
            const mensajes = [
                "Preparando tu arsenal de testing...",
                "Cargando casos de prueba...",
                "Sincronizando con el servidor...",
                "Configurando workspace...",
                "Casi listo...",
                "Verificando permisos...",
                "Conectando con Google Sheets...",
            ];

            const tips = [
                "ğŸ’¡ Tip: Organiza tus casos por mÃ³dulos",
                "ğŸ’¡ Tip: Usa etiquetas descriptivas en tus bugs",
                "ğŸ’¡ Tip: Los casos crÃ­ticos van primero",
                "ğŸ’¡ Tip: Documenta los pasos claramente",
                "ğŸ’¡ Tip: Adjunta evidencias a tus ejecuciones",
            ];

            const mensajeAleatorio =
                mensajes[Math.floor(Math.random() * mensajes.length)];
            const tipAleatorio = tips[Math.floor(Math.random() * tips.length)];

            const loadingMessage = document.getElementById("loadingMessage");
            const loadingTip = document.getElementById("loadingTip");

            if (loadingMessage) loadingMessage.textContent = mensajeAleatorio;
            if (loadingTip) loadingTip.textContent = tipAleatorio;
        }
    }

    function ocultarSpinner() {
        const overlay = document.getElementById("loadingOverlay");
        if (overlay) {
            overlay.classList.remove("active");
        }
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // FUNCIONES DE NOTIFICACIONES
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function mostrarToast(mensaje, tipo = "success", duracion = 3000) {
        const notification = document.getElementById("notification");
        const icon = document.getElementById("notificationIcon");
        const messageEl = document.getElementById("notificationMessage");

        if (!notification) return;

        // Configurar icono segÃºn tipo
        const iconos = {
            success: "âœ“",
            error: "âœ•",
            warning: "âš ï¸",
            info: "â„¹ï¸",
        };

        // Aplicar estilos segÃºn tipo
        notification.className = "notification show " + tipo;
        icon.textContent = iconos[tipo] || "âœ“";
        messageEl.textContent = mensaje;

        // Mostrar notificaciÃ³n
        setTimeout(() => {
            notification.classList.add("show");
        }, 100);

        // Ocultar despuÃ©s de la duraciÃ³n
        setTimeout(() => {
            notification.classList.remove("show");
        }, duracion);
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // FUNCIONES DE MODALES CON NAVEGACIÃ“N POR TECLADO
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    let modalStack = []; // Stack de modales abiertos
    let focusBeforeModal = null; // Elemento con foco antes de abrir modal

    /**
     * Abre un modal con trap de foco y soporte para teclado
     * @param {string} modalId - ID del modal a abrir
     */
    function abrirModal(modalId) {
        const modal = document.getElementById(modalId);
        if (!modal) return;

        // Guardar el foco actual
        focusBeforeModal = document.activeElement;

        // Agregar al stack
        modalStack.push(modalId);

        // Mostrar modal
        modal.classList.add("active");
        document.body.style.overflow = "hidden";

        // Aplicar trap de foco
        aplicarTrapDeFoco(modal);

        // Focus en primer elemento focusable
        setTimeout(() => {
            const primerFocusable = obtenerElementosFocusables(modal)[0];
            if (primerFocusable) {
                primerFocusable.focus();
            }
        }, 100);

        // Listener para ESC
        modal.addEventListener("keydown", manejarEscapeModal);
    }

    /**
     * Cierra un modal y restaura el foco
     * @param {string} modalId - ID del modal a cerrar
     */
    function cerrarModal(modalId) {
        const modal = document.getElementById(modalId);
        if (!modal) return;

        // Remover del stack
        const index = modalStack.indexOf(modalId);
        if (index > -1) {
            modalStack.splice(index, 1);
        }

        // Ocultar modal
        modal.classList.remove("active");

        // Remover trap de foco
        removerTrapDeFoco(modal);

        // Remover listener de ESC
        modal.removeEventListener("keydown", manejarEscapeModal);

        // Restaurar overflow solo si no hay mÃ¡s modales
        if (modalStack.length === 0) {
            document.body.style.overflow = "auto";

            // Restaurar foco
            if (focusBeforeModal && focusBeforeModal.focus) {
                focusBeforeModal.focus();
            }
        }
    }

    /**
     * Obtiene todos los elementos focusables dentro de un contenedor
     * @param {HTMLElement} container - Contenedor
     * @returns {Array} - Array de elementos focusables
     */
    function obtenerElementosFocusables(container) {
        const selector =
            'a[href], button:not([disabled]), textarea:not([disabled]), input:not([disabled]), select:not([disabled]), [tabindex]:not([tabindex="-1"])';
        return Array.from(container.querySelectorAll(selector)).filter((el) => {
            return el.offsetParent !== null; // Solo elementos visibles
        });
    }

    /**
     * Aplica trap de foco a un modal
     * @param {HTMLElement} modal - Modal
     */
    function aplicarTrapDeFoco(modal) {
        modal.addEventListener("keydown", function (e) {
            if (e.key !== "Tab") return;

            const focusables = obtenerElementosFocusables(modal);
            if (focusables.length === 0) return;

            const primerFocusable = focusables[0];
            const ultimoFocusable = focusables[focusables.length - 1];

            // Shift + Tab en el primer elemento -> ir al Ãºltimo
            if (e.shiftKey && document.activeElement === primerFocusable) {
                e.preventDefault();
                ultimoFocusable.focus();
            }
            // Tab en el Ãºltimo elemento -> ir al primero
            else if (
                !e.shiftKey &&
                document.activeElement === ultimoFocusable
            ) {
                e.preventDefault();
                primerFocusable.focus();
            }
        });
    }

    /**
     * Remueve trap de foco de un modal
     * @param {HTMLElement} modal - Modal
     */
    function removerTrapDeFoco(modal) {
        // Los listeners se limpian automÃ¡ticamente al cerrar
        // pero podrÃ­amos usar removeEventListener si guardÃ¡ramos la referencia
    }

    /**
     * Maneja la tecla ESC para cerrar modales
     * @param {KeyboardEvent} e - Evento de teclado
     */
    function manejarEscapeModal(e) {
        if (e.key === "Escape") {
            // Cerrar el Ãºltimo modal del stack
            if (modalStack.length > 0) {
                const ultimoModal = modalStack[modalStack.length - 1];
                cerrarModal(ultimoModal);
            }
        }
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // FUNCIONES DE UTILIDAD
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    /**
     * Retorna la clase de badge segÃºn la prioridad del caso
     * @param {string} prioridad - Prioridad del caso (Critica, Alta, Media, Baja)
     * @returns {string} - Clase CSS del badge
     * @example getBadgePrioridad('Critica') // 'badge-danger'
     */
    function getBadgePrioridad(prioridad) {
        const badges = {
            Critica: "badge-danger",
            Alta: "badge-warning",
            Media: "badge-info",
            Baja: "badge-success",
        };
        return badges[prioridad] || "badge-primary";
    }

    /**
     * Retorna la clase de badge segÃºn el estado del caso
     * @param {string} estado - Estado del caso (OK, No_OK, Pendiente, etc.)
     * @returns {string} - Clase CSS del badge
     * @example getBadgeEstado('OK') // 'badge-success'
     */
    function getBadgeEstado(estado) {
        const badges = {
            OK: "badge-success",
            No_OK: "badge-danger",
            Pendiente: "badge-warning",
            "En diseÃ±o": "badge-info",
            "En diseno": "badge-info",
            Ejecutando: "badge-primary",
        };
        return badges[estado] || "badge-primary";
    }

    /**
     * Formatea una fecha al formato espaÃ±ol (dd/mm/yyyy)
     * @param {string|Date} fecha - Fecha a formatear
     * @returns {string} - Fecha formateada o '-' si es invÃ¡lida
     * @example formatearFecha('2025-01-15') // '15/1/2025'
     */
    function formatearFecha(fecha) {
        if (!fecha) return "-";
        const date = typeof fecha === "string" ? new Date(fecha) : fecha;
        return date.toLocaleDateString("es-ES");
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // MANEJO DE ERRORES GLOBAL
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    window.onerror = function (msg, url, lineNo, columnNo, error) {
        console.error("Error global:", msg, "en lÃ­nea:", lineNo);
        return false;
    };

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // SEGURIDAD: SANITIZACIÃ“N DE HTML (PrevenciÃ³n XSS)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    /**
     * Escapa caracteres HTML para prevenir XSS
     * @param {string} text - Texto a sanitizar
     * @returns {string} - Texto seguro sin HTML
     */
    function escapeHtml(text) {
        if (!text) return "";

        const map = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#039;",
            "/": "&#x2F;",
        };

        return String(text).replace(/[&<>"'\/]/g, function (m) {
            return map[m];
        });
    }

    /**
     * Sanitiza HTML permitiendo solo tags seguros especÃ­ficos
     * @param {string} html - HTML a sanitizar
     * @param {Array} allowedTags - Tags permitidos (por defecto: br, strong, em, p)
     * @returns {string} - HTML sanitizado
     */
    function sanitizeHtml(html, allowedTags) {
        if (!html) return "";

        allowedTags = allowedTags || ["br", "strong", "em", "p", "b", "i", "u"];

        // Primero escapar todo
        let safe = escapeHtml(html);

        // Luego permitir solo tags especÃ­ficos
        allowedTags.forEach(function (tag) {
            const openRegex = new RegExp("&lt;" + tag + "&gt;", "gi");
            const closeRegex = new RegExp("&lt;\\/" + tag + "&gt;", "gi");
            safe = safe.replace(openRegex, "<" + tag + ">");
            safe = safe.replace(closeRegex, "</" + tag + ">");
        });

        return safe;
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // VALIDACIÃ“N EN TIEMPO REAL
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    /**
     * Valida un campo de formulario en tiempo real
     * @param {HTMLElement} input - El elemento input/textarea a validar
     * @param {Object} options - Opciones de validaciÃ³n
     */
    function validarCampoEnTiempoReal(input, options) {
        if (!input) return;

        options = options || {};
        const minLength =
            options.minLength || input.getAttribute("minlength") || 0;
        const maxLength =
            options.maxLength || input.getAttribute("maxlength") || Infinity;
        const required =
            options.required !== undefined
                ? options.required
                : input.hasAttribute("required");
        const pattern = options.pattern || input.getAttribute("pattern");
        const customValidator = options.validator; // FunciÃ³n personalizada

        const value = input.value || "";
        const currentLength = value.length;

        // Encontrar o crear elementos de feedback
        let errorDiv = input.nextElementSibling;
        if (!errorDiv || !errorDiv.classList.contains("form-error")) {
            errorDiv = document.createElement("div");
            errorDiv.className = "form-error hidden";
            input.parentNode.insertBefore(errorDiv, input.nextSibling);
        }

        let counterSpan = input.parentNode.querySelector(".char-counter");

        // Array de errores
        const errors = [];

        // Validar requerido
        if (required && currentLength === 0) {
            errors.push("Este campo es obligatorio");
        }

        // Validar longitud mÃ­nima (solo si hay contenido)
        if (currentLength > 0 && currentLength < minLength) {
            errors.push(
                `MÃ­nimo ${minLength} caracteres (tienes ${currentLength})`
            );
        }

        // Validar longitud mÃ¡xima
        if (currentLength > maxLength) {
            errors.push(
                `MÃ¡ximo ${maxLength} caracteres (tienes ${currentLength})`
            );
        }

        // Validar patrÃ³n
        if (pattern && currentLength > 0) {
            const regex = new RegExp(pattern);
            if (!regex.test(value)) {
                errors.push(options.patternMessage || "Formato invÃ¡lido");
            }
        }

        // ValidaciÃ³n personalizada
        if (customValidator && typeof customValidator === "function") {
            const customError = customValidator(value);
            if (customError) {
                errors.push(customError);
            }
        }

        // Mostrar/ocultar errores
        if (errors.length > 0) {
            errorDiv.textContent = errors[0]; // Mostrar primer error
            errorDiv.classList.remove("hidden");
            input.classList.add("error");
            input.setCustomValidity(errors[0]); // HTML5 validation API
        } else {
            errorDiv.classList.add("hidden");
            input.classList.remove("error");
            input.setCustomValidity(""); // Limpiar error HTML5
        }

        // Actualizar contador si existe
        if (counterSpan) {
            const currentSpan = counterSpan.querySelector(".current");
            if (currentSpan) {
                currentSpan.textContent = currentLength;

                // Color del contador
                if (currentLength >= minLength) {
                    currentSpan.classList.add("valid");
                } else {
                    currentSpan.classList.remove("valid");
                }
            }
        }

        return errors.length === 0;
    }

    /**
     * Configura validaciÃ³n en tiempo real para un formulario completo
     * @param {string|HTMLElement} formIdOrElement - ID del formulario o elemento
     * @param {Object} fieldsConfig - ConfiguraciÃ³n de cada campo
     */
    function configurarValidacionFormulario(formIdOrElement, fieldsConfig) {
        const form =
            typeof formIdOrElement === "string"
                ? document.getElementById(formIdOrElement)
                : formIdOrElement;

        if (!form) return;

        // Para cada campo configurado
        Object.keys(fieldsConfig).forEach(function (fieldId) {
            const input = document.getElementById(fieldId);
            if (!input) return;

            const config = fieldsConfig[fieldId];

            // Agregar evento input para validaciÃ³n en tiempo real
            input.addEventListener("input", function () {
                validarCampoEnTiempoReal(input, config);
            });

            // Agregar evento blur para validar al salir del campo
            input.addEventListener("blur", function () {
                validarCampoEnTiempoReal(input, config);
            });
        });

        // Prevenir submit si hay errores
        form.addEventListener("submit", function (e) {
            let hasErrors = false;

            Object.keys(fieldsConfig).forEach(function (fieldId) {
                const input = document.getElementById(fieldId);
                if (!input) return;

                const isValid = validarCampoEnTiempoReal(
                    input,
                    fieldsConfig[fieldId]
                );
                if (!isValid) {
                    hasErrors = true;
                }
            });

            if (hasErrors) {
                e.preventDefault();
                mostrarToast(
                    "Por favor corrige los errores antes de continuar",
                    "warning"
                );
            }
        });
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // SISTEMA DE MANEJO DE ERRORES TIPIFICADOS
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    const ErrorTypes = {
        NETWORK: "network",
        PERMISSION: "permission",
        TIMEOUT: "timeout",
        VALIDATION: "validation",
        NOT_FOUND: "not_found",
        SERVER_ERROR: "server_error",
        UNKNOWN: "unknown",
    };

    const ErrorMessages = {
        [ErrorTypes.NETWORK]: {
            title: "Sin conexiÃ³n",
            message: "VerificÃ¡ tu conexiÃ³n a internet e intentÃ¡ de nuevo",
            action: "Reintentar",
            icon: "ğŸ“¡",
            color: "#f59e0b",
        },
        [ErrorTypes.PERMISSION]: {
            title: "Sin permisos",
            message:
                "No tenÃ©s acceso a este recurso. SolicitÃ¡ permisos al propietario del Google Sheet.",
            action: "Contactar",
            icon: "ğŸ”’",
            color: "#ef4444",
        },
        [ErrorTypes.TIMEOUT]: {
            title: "Tiempo agotado",
            message:
                "La operaciÃ³n tardÃ³ demasiado. IntentÃ¡ nuevamente o contactÃ¡ soporte si persiste.",
            action: "Reintentar",
            icon: "â±ï¸",
            color: "#f59e0b",
        },
        [ErrorTypes.VALIDATION]: {
            title: "Datos invÃ¡lidos",
            message:
                "Algunos campos tienen errores. VerificÃ¡ los datos ingresados y volvÃ© a intentar.",
            action: "Revisar",
            icon: "âš ï¸",
            color: "#f59e0b",
        },
        [ErrorTypes.NOT_FOUND]: {
            title: "No encontrado",
            message: "El recurso solicitado no existe o fue eliminado.",
            action: "Volver",
            icon: "ğŸ”",
            color: "#64748b",
        },
        [ErrorTypes.SERVER_ERROR]: {
            title: "Error del servidor",
            message:
                "OcurriÃ³ un error en el servidor. El equipo tÃ©cnico fue notificado.",
            action: "Cerrar",
            icon: "âš™ï¸",
            color: "#ef4444",
        },
        [ErrorTypes.UNKNOWN]: {
            title: "Error inesperado",
            message:
                "Algo saliÃ³ mal. Si el problema persiste, contactÃ¡ soporte tÃ©cnico.",
            action: "Cerrar",
            icon: "âŒ",
            color: "#991b1b",
        },
    };

    /**
     * Detecta el tipo de error basado en el mensaje o error object
     * @param {Error|string} error - El error a clasificar
     * @returns {string} - Tipo de error
     */
    function detectarTipoError(error) {
        const errorMsg = (
            typeof error === "string" ? error : error.message || ""
        ).toLowerCase();

        if (
            errorMsg.includes("network") ||
            errorMsg.includes("conexiÃ³n") ||
            errorMsg.includes("offline")
        ) {
            return ErrorTypes.NETWORK;
        }
        if (
            errorMsg.includes("permission") ||
            errorMsg.includes("permiso") ||
            errorMsg.includes("access denied")
        ) {
            return ErrorTypes.PERMISSION;
        }
        if (errorMsg.includes("timeout") || errorMsg.includes("timed out")) {
            return ErrorTypes.TIMEOUT;
        }
        if (
            errorMsg.includes("validation") ||
            errorMsg.includes("invalid") ||
            errorMsg.includes("invÃ¡lido")
        ) {
            return ErrorTypes.VALIDATION;
        }
        if (errorMsg.includes("not found") || errorMsg.includes("404")) {
            return ErrorTypes.NOT_FOUND;
        }
        if (
            errorMsg.includes("server error") ||
            errorMsg.includes("500") ||
            errorMsg.includes("503")
        ) {
            return ErrorTypes.SERVER_ERROR;
        }

        return ErrorTypes.UNKNOWN;
    }

    /**
     * Muestra un error tipificado con UI mejorada
     * @param {Error|string} error - El error a mostrar
     * @param {string} tipoManual - Tipo de error manual (opcional)
     * @param {Object} opciones - Opciones adicionales
     */
    function mostrarErrorTipificado(error, tipoManual, opciones) {
        opciones = opciones || {};

        const tipo = tipoManual || detectarTipoError(error);
        const errorInfo =
            ErrorMessages[tipo] || ErrorMessages[ErrorTypes.UNKNOWN];

        // Si solo queremos un toast simple
        if (opciones.simple) {
            mostrarToast(errorInfo.message, "error");
            return;
        }

        // Modal de error completo
        const errorModal = document.createElement("div");
        errorModal.className = "modal-overlay active";
        errorModal.style.zIndex = "var(--z-confirmation)";
        errorModal.id = "errorModal";

        const detalles =
            typeof error === "object" && error.message ? error.message : error;

        errorModal.innerHTML = `
    <div class="modal" style="max-width: 500px;">
      <div class="modal-header" style="background: ${
          errorInfo.color
      }; color: white;">
        <h3 class="modal-title" style="color: white;">
          <span style="font-size: 1.5rem; margin-right: 0.5rem;">${
              errorInfo.icon
          }</span>
          ${errorInfo.title}
        </h3>
        <button class="modal-close" style="color: white;" onclick="cerrarErrorModal()">âœ•</button>
      </div>

      <div class="modal-body">
        <p style="font-size: 1rem; line-height: 1.6; margin-bottom: 1rem;">
          ${errorInfo.message}
        </p>

        ${
            detalles
                ? `
          <details style="background: #f8fafc; padding: 0.75rem; border-radius: 6px; margin-top: 1rem;">
            <summary style="cursor: pointer; font-weight: 600; color: var(--text-secondary);">
              Detalles tÃ©cnicos
            </summary>
            <pre style="margin-top: 0.75rem; font-size: 0.85rem; white-space: pre-wrap; word-break: break-word; color: var(--text-tertiary);">${escapeHtml(
                detalles
            )}</pre>
          </details>
        `
                : ""
        }
      </div>

      <div class="modal-footer">
        <button class="btn btn-primary" onclick="cerrarErrorModal(); ${
            opciones.onAction || ""
        }">
          ${errorInfo.action}
        </button>
      </div>
    </div>
  `;

        document.body.appendChild(errorModal);
    }

    /**
     * Cierra el modal de error
     */
    function cerrarErrorModal() {
        const errorModal = document.getElementById("errorModal");
        if (errorModal) {
            errorModal.remove();
        }
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // FUNCIONES DE DEPURACIÃ“N
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function debugLog(mensaje, datos) {
        console.log(`[DEBUG] ${mensaje}`, datos || "");
    }

    // Verificar que las funciones crÃ­ticas estÃ©n disponibles
    window.addEventListener("DOMContentLoaded", function () {
        debugLog("DOM cargado completamente");

        // Verificar funciones crÃ­ticas
        const funcionesCriticas = [
            "mostrarSpinner",
            "ocultarSpinner",
            "mostrarToast",
            "abrirModal",
            "cerrarModal",
        ];

        funcionesCriticas.forEach((func) => {
            if (typeof window[func] === "function") {
                debugLog(`âœ… FunciÃ³n ${func} disponible`);
            } else {
                console.error(`âŒ FunciÃ³n ${func} NO disponible`);
            }
        });
    });

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // INICIALIZACIÃ“N SEGURA
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    // Asegurar que las funciones estÃ©n disponibles globalmente
    window.mostrarSpinner = mostrarSpinner;
    window.ocultarSpinner = ocultarSpinner;
    window.mostrarToast = mostrarToast;
    window.abrirModal = abrirModal;
    window.cerrarModal = cerrarModal;
    window.getBadgePrioridad = getBadgePrioridad;
    window.getBadgeEstado = getBadgeEstado;
    window.formatearFecha = formatearFecha;
    window.escapeHtml = escapeHtml;
    window.sanitizeHtml = sanitizeHtml;
    window.validarCampoEnTiempoReal = validarCampoEnTiempoReal;
    window.configurarValidacionFormulario = configurarValidacionFormulario;
    window.ErrorTypes = ErrorTypes;
    window.mostrarErrorTipificado = mostrarErrorTipificado;
    window.detectarTipoError = detectarTipoError;
    window.cerrarErrorModal = cerrarErrorModal;

    console.log("âœ… Frontend Scripts Main cargado correctamente");
</script>
